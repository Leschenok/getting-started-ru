
Если вы не заметили, наш список задач очищается каждый раз, когда мы 
запускаем контейнер. Почему это? Давайте углубимся в то, как работает 
контейнер. 

## Файловая система контейнера

Когда контейнер запускается, он использует различные слои образа для своей 
файловой системы. Каждый контейнер также получает свое собственное 
"рабочее пространство" ("scratch space") для создания/обновления/удаления файлов. 
Любые изменения не будут видны в другом контейнере, _даже если_ они используют тот же образ. 

### Увидеть это на практике

Чтобы увидеть это в действии, мы запустим два контейнера и создадим файл в каждом.
Вы увидите, что файлы, созданные в одном контейнере, недоступны в другом.

1. Запустите контейнер `ubuntu` который создаст файл с именем `/data.txt` со случайным номером.
    от 1 до 10000.

    ```bash
    docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
    ```

    Если вам интересно узнать об этой команде, мы запускаем оболочку bash и вызываем 
    две команды (почему у нас есть `&&`). Первая часть выбирает одно случайное число и записывает его в `/data.txt`. 
    Вторая команда просто просматривает файл, чтобы контейнер работал.

1. Подтвердите, что мы можем видеть выходные данные, введя команду `excec` в контейнере. 
   Для этого откройте панель мониторинга, найдите свой контейнер Ubuntu, щелкните меню "тройная точка", 
   чтобы получить дополнительные действия, и выберите пункт меню "Open in terminal".

    ![Dashboard open CLI into ubuntu container](dashboard-open-cli-ubuntu.png){: style=width:75% }
{: .text-center }

    В контейнере Ubuntu вы увидите терминал, на котором запущена оболочка. 
    Запустите следующую команду, чтобы просмотреть содержимое файла `/data.txt`. После этого снова закройте этот терминал.

    ```bash
    cat /data.txt
    ```

    Если вы предпочитаете командную строку, вы можете использовать команду `docker exec`, чтобы сделать то же самое. 
    Вам нужно получить идентификатор контейнера (для его получения используйте `docker ps`) и получить содержимое с помощью следующей команды.

    ```bash
    docker exec <container-id> cat /data.txt
    ```

    Вы должны увидеть случайное число!

1. Теперь давайте запустим другой контейнер `ubuntu` (тот же образ) и увидим, что у нас нет того же файла.

    ```bash
    docker run -it ubuntu ls /
    ```

    И посмотри! Там нет файла `data.txt`! Это потому, что он был записан в рабочее пространство только для первого контейнера.

1. Удалите первый контейнер с помощью команды `docker rm -f <container-id>`.
    ```bash
    docker rm -f <container-id>
    ```

## Тома контейнеров

В предыдущем эксперименте мы увидели, что каждый контейнер каждый раз 
запускается с определения образа. Хотя контейнеры могут создавать, 
обновлять и удалять файлы, эти изменения теряются при удалении контейнера, 
и все изменения изолируются в этом контейнере. С помощью объемов мы можем 
все это изменить. 

[Volumes (Тома)](https://docs.docker.com/storage/volumes/) предоставляют возможность 
подключать определенные пути файловой системы контейнера обратно к 
хост-компьютеру. Если каталог в контейнере смонтирован, изменения в этом 
каталоге также видны на хост-компьютере. Если мы смонтируем один и тот же 
каталог при перезапуске контейнера, мы увидим одни и те же файлы. 

Существует два основных типа томов. В конечном итоге мы будем использовать оба, но начнем с **именованных томов** (**named volumes**).

## Сохранение наших данных задач

По умолчанию приложение todo сохраняет свои данные в [базе данных SQLite](https://www.sqlite.org/index.html) по адресу `/etc/todos/todo.db`. 
Если вы не знакомы с SQLite, не беспокойтесь! Это просто реляционная база данных в где все данные хранятся в одном файле. 
Хотя это не лучший вариант для крупномасштабных приложений, он работает для небольших демонстраций. О переключении на другой механизм базы данных мы поговорим позже.

Поскольку база данных представляет собой один файл, и если мы сможем сохранить этот файл на хосте и сделать его доступным для следующего контейнера, 
он сможет продолжить с того места, где остановился последний. 
Создав том и прикрепив (часто называемое "монтирование" - "mounting") в каталог, в котором хранятся данные, мы можем сохранить данные. 
Когда наш контейнер записывает данные в файл `todo.db`, он сохраняется на хосте тома.

Как уже упоминалось, мы собираемся использовать **именованный том** (**named volume**). 
Думайте об именованном томе как о просто наборе данных. Docker сохраняет физическое местоположение на диске, и вам нужно только запомнить имя тома. 
Каждый раз, когда вы используете том, Docker проверяет, предоставлены ли правильные данные.

1. Создайте том с помощью команды `docker volume create`.

    ```bash
    docker volume create todo-db
    ```

1. Остановите контейнер приложения todo еще раз на панели управления (или с помощью `docker rm -f <container-id>`), так как он все еще работает без использования постоянного тома.

1. Запустите контейнер приложения todo, но добавьте флаг `-v`, чтобы указать монтирование тома. 
Мы будем использовать указанный том и смонтировать его в `/etc/todos`, который будет сохранять все файлы, созданные по этому пути.

    ```bash
    docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
    ```

1. Как только контейнер запустится, откройте приложение и добавьте несколько элементов в свой список дел.

    ![Items added to todo list](items-added.png){: style="width: 55%; " }
    {: .text-center }

1. Удалите контейнер приложения todo. Используйте панель управления или `docker ps`, чтобы получить идентификатор, а затем `docker rm -f <container-id>`, чтобы удалить его.

1. Запустите новый контейнер, используя ту же команду, что и выше.

1. Откройте приложение. Вы должны видеть, что ваши товары все еще находятся в вашем списке!

1. Удалите контейнер, когда закончите проверять свой список.

Ура! Теперь вы узнали, как сохранять данные!

!!! info "Совет профессионала"
    Хотя именованные тома и привязки (bind mounts, о которых мы поговорим через минуту) являются двумя основными типами томов, поддерживаемыми стандартной 
    установкой движка Docker, существует множество подключаемых модулей драйверов томов для поддержки NFS, SFTP, NetApp и других! 
    Это будет особенно важно, когда вы начнете запускать контейнеры на нескольких хостах в кластерной среде с Swarm, Kubernetes и т.д.

## Погружение в наш том

Многие люди часто спрашивают: "Где Docker _на самом деле_ хранит мои данные, когда я использую именованный том?" 
Если вы хотите знать, вы можете использовать команду `docker volume inspect`.

```bash
docker volume inspect todo-db
[
    {
        "CreatedAt": "2019-09-26T02:18:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": {},
        "Scope": "local"
    }
]
```

`Mountpoint` - `Точка монтирования` - это фактическое место на диске, где хранятся данные. 
Обратите внимание, что на большинстве машин вам потребуется root-доступ для доступа к этому каталогу с хоста. 
Но вот оно где!

!!! info "Доступ к данным тома непосредственно на Docker Desktop"
    При работе в Docker Desktop команды Docker фактически выполняются внутри небольшой виртуальной машины на вашем компьютере.
    Если вы хотите просмотреть фактическое содержимое каталога точки монтирования, вам нужно сначала проникнуть внутрь виртуальной машины.

## Резюме

На данный момент у нас есть работающее приложение, способное пережить перезагрузку! 
Мы можем продемонстрировать это нашим инвесторам и надеяться, что они поймут наше видение! 

Однако ранее мы видели, что восстановление обраазов для каждого изменения занимает довольно много времени. 
Должен быть лучший способ внести изменения, верно? 
С привязками (bind mounts, на которые мы намекали ранее) есть лучший способ! Давайте посмотрим на это сейчас!
