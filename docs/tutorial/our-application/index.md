
В оставшейся части этого руководства мы будем работать с простым 
менеджером списков дел, работающим в Node.js. Если вы не знакомы с 
Node.js, не волнуйтесь! Никакого реального опыта работы с JavaScript не 
требуется! 

На данный момент ваша команда разработчиков довольно мала, и вы просто 
создаете приложение, чтобы доказать свой MVP (минимально жизнеспособный 
продукт). Вы хотите показать, как он работает и на что он способен, не 
задумываясь о том, как он будет работать в большой команде, нескольких 
разработчиках и т. д. 

![Todo List Manager Screenshot](todo-list-sample.png){: style="width:50%;" }
{ .text-center }

## Как получить наше приложение

Прежде чем мы сможем запустить приложение, нам нужно загрузить исходный 
код приложения на нашу машину. Для реальных проектов вы обычно клонируете 
репозиторий. Но для этого урока мы создали ZIP-файл, содержащий 
приложение. 

1. [Download the ZIP](/assets/app.zip). Откройте ZIP-файл и убедитесь, что 
вы извлекли его содержимое.

1. После извлечения откройте проект в своем любимом редакторе кода. Если 
вам нужен редактор, вы можете использовать [Visual Studio Code](https://code.visualstudio.com/). 
Вы должны увидеть `package.json` и два подкаталога (`src` и `spec`).

    ![Screenshot of Visual Studio Code opened with the app loaded](ide-screenshot.png){: style="width:650px;margin-top:20px;"}
    {: .text-center }

## Создание образа контейнера приложения

Чтобы создать приложение, нам нужно использовать `Dockerfile` Dockerfile - 
это просто текстовый сценарий инструкций, который используется для 
создания образа контейнера. Если вы уже создавали Dockerfiles, вы можете 
увидеть несколько недостатков в Dockerfile ниже. Но не волнуйтесь! Мы 
пройдемся по ним. 

1. Создайте файл с именем `Dockerfile` в той же папке, что и файл `package.json`, со следующим содержимым.

    ```dockerfile
    FROM node:18-alpine
    WORKDIR /app
    COPY . .
    RUN yarn install --production
    CMD ["node", "./src/index.js"]
    ```

    Убедитесь, что файл `Dockerfile` не имеет расширения типа `.txt`. Некоторые редакторы могут автоматически добавлять это расширение файла, и это приведет к ошибке на следующем шаге.

1. Если вы еще этого не сделали, откройте терминал и перейдите в каталог `app` с файлом `Dockerfile`. Теперь создайте образ контейнера с помощью команды `docker build`.

    ```bash
    docker build -t getting-started .
    ```

    This command used the Dockerfile to build a new container image. You might
    have noticed that a lot of "layers" were downloaded. This is because we instructed
    the builder that we wanted to start from the `node:18-alpine` image. But, since we
    didn't have that on our machine, that image needed to be downloaded.

    After the image was downloaded, we copied in our application and used `yarn` to 
    install our application's dependencies. The `CMD` directive specifies the default 
    command to run when starting a container from this image.

    Finally, the `-t` flag tags our image. Think of this simply as a human-readable name
    for the final image. Since we named the image `getting-started`, we can refer to that
    image when we run a container.

    Эта команда использовала Dockerfile для создания нового образа контейнера. 
    Вы могли заметить, что было загружено много "слоев". Это потому, что мы проинструктировали сборщика, что хотим начать с образа 
    `node:18-alpine`. Но поскольку на нашей машине его не было, этот образ необходимо было загрузить. 

    После загрузки образа мы скопировали его в наше приложение и использовали `yarn` для установки зависимостей нашего приложения. 
    Директива `CMD` определяет команду по умолчанию, которая будет запускаться при запуске контейнера из этого образа. 

    Наконец, флаг `-t` помечает наш образ. Думайте об этом просто как об удобочитаемом имени конечного образа. 
    Поскольку мы назвали образ `getting-started`, мы можем обращаться к этому образу при запуске контейнера.

    `.` в конце команды `docker build` сообщает, что Docker должен искать `Dockerfile` в текущем каталоге.

## Запуск контейнера приложения

Теперь, когда у нас есть образ, давайте запустим приложение! Для 
этого мы будем использовать команду `docker run` (помните это ранее?).

1. Запустите ваш контейнер с помощью команды `docker run` и укажите имя только что созданного нами образа:

    ```bash
    docker run -dp 3000:3000 getting-started
    ```

    Помните флаги `-d` и `-p`? Мы запускаем новый контейнер в "отключенном (detached)" режиме 
    (в фоновом режиме) и создаем сопоставление между портом 3000 хоста и портом 3000 контейнера. 
    Без сопоставления портов мы не сможем получить доступ к приложению.

1. Через несколько секунд откройте веб-браузер на [http://localhost:3000](http://localhost:3000).
    Вы должны увидеть наше приложение!

    ![Empty Todo List](todo-list-empty.png){: style="width:450px;margin-top:20px;"}
    {: .text-center }

1. Добавьте один или два элемента и убедитесь, что они работают так, как вы ожидаете. 
   Вы можете отмечать элементы как завершенные и удалять их. Ваш интерфейс успешно хранит элементы на сервере!
   Довольно быстро и легко, да?

На этом этапе у вас должен быть работающий менеджер списков задач с 
несколькими элементами, созданными вами! Теперь давайте внесем несколько 
изменений и научимся управлять нашими контейнерами. 

Если вы быстро взглянете на панель управления Docker, вы увидите, что ваши 
два контейнера сейчас работают (это руководство и ваш только что 
запущенный контейнер приложения)! 

![Docker Dashboard with tutorial and app containers running](dashboard-two-containers.png)

## Резюме

В этом коротком разделе мы изучили самые основы создания образа контейнера 
и создали для этого Dockerfile. Создав образ, мы запустили контейнер и 
увидели работающее приложение! 

Далее мы собираемся внести изменения в наше приложение и узнать, как 
обновить наше работающее приложение новым образом. Попутно мы выучим еще 
несколько полезных команд.
