
В предыдущей главе мы говорили о **именованном томе** и использовали его 
для сохранения данных в нашей базе данных. Именованные тома отлично 
подходят, если мы просто хотим хранить данные, поскольку нам не нужно 
беспокоиться о том, _где_ хранятся данные. 

С помощью **bind mounts** мы контролируем точную точку монтирования на 
хосте. Мы можем использовать это для сохранения данных, но часто оно 
используется для предоставления дополнительных данных в контейнеры. При 
работе над приложением мы можем использовать привязку для монтирования 
исходного кода в контейнер, чтобы он мог видеть изменения кода, 
реагировать и сразу же видеть изменения.

Для приложений на базе Node [nodemon](https://npmjs.com/package/nodemon) - 
отличный инструмент для отслеживания изменений файлов и последующего 
перезапуска приложения. Эквивалентные инструменты существуют в большинстве 
других языков и фреймворков.

## Быстрое сравнение типов томов

Привязка монтирования и именованные тома - это два основных типа томов, 
поставляемых с движком Docker. 
Однако доступны дополнительные драйверы томов для поддержки других вариантов использования
([SFTP](https://github.com/vieux/docker-volume-sshfs), [Ceph](https://ceph.com/geen-categorie/getting-started-with-the-docker-rbd-volume-plugin/), 
[NetApp](https://netappdvp.readthedocs.io/en/stable/), [S3](https://github.com/elementar/docker-s3-volume), и многое другое).

||Именованные тома<br/>Named Volumes|Привязка монтирования<br/>Bind Mounts|
|---|---|---|
|Местоположение хоста|Выбирает Docker|Вы контролируете|
|Пример монтирования<br/>(с использованием `-v`)|`my-volume:/usr/local/data`|`/path/to/data:/usr/local/data`|
|Заполняет новый том содержимым контейнера|Да|Нет|
|Поддерживает драйверы тома|Да|Нет|


## Запуск контейнера в режиме разработки

Чтобы запустить наш контейнер для поддержки рабочего процесса разработки, мы сделаем следующее:

- Монтируем наш исходный код в контейнер
- Установите все зависимости, включая зависимости "dev".
- Запустите nodemon, чтобы следить за изменениями файловой системы.

Итак, давайте сделаем это!

1. Убедитесь, что у вас не запущен ни один из ваших собственных контейнеров `getting-started` (должен быть запущен только сам учебник).

1. Также убедитесь, что вы находитесь в каталоге исходного кода приложения, т.е. `/path/to/getting-started/app`. Если это не так, вы можете войти в него с помощью `cd`, например:

    ```bash
    cd /path/to/getting-started/app
    ```

1. Теперь, когда вы находитесь в каталоге `getting-started/app`, выполните следующую команду. Далее мы объясним, что происходит:

    ```bash
    docker run -dp 3000:3000 \
        -w /app -v "$(pwd):/app" \
        node:18-alpine \
        sh -c "yarn install && yarn run dev"
    ```

    Если вы используете PowerShell, используйте эту команду.

    ```powershell
    docker run -dp 3000:3000 `
        -w /app -v "$(pwd):/app" `
        node:18-alpine `
        sh -c "yarn install && yarn run dev"
    ```

    - `-dp 3000:3000` - то же, что и раньше. Запустите в автономном (фоновом) режиме и создайте сопоставление портов.
    - `-w /app` - устанавливает текущий рабочий каталог контейнера, из которого будет запускаться команда.
    - `-v "$(pwd):/app"` - связать монтирование (ссылку) текущего каталога `getting-started/app` хоста с каталогом `/app` контейнера. 
      Примечание. Docker требует абсолютных путей для монтирования привязки, поэтому в этом примере мы используем `pwd` для печати абсолютного пути к рабочему каталогу, то есть каталогу `app`, вместо того, чтобы вводить его вручную.
    - `node:18-alpine` - образ, который нужно использовать. Обратите внимание: это базовый образ нашего приложения из Dockerfile.
    - `sh -c "yarn install && Yarn run dev"` - команда. Мы запускаем оболочку с помощью `sh` (в Alpine нет `bash`) и
       запустим `yarn install` для установки _всех_ зависимостей, а затем запустим `yarn run dev`. 
      Если мы посмотрим в `package.json`, мы увидим, что сценарий `dev` запускает `nodemon`.
  
1. Вы можете просмотреть журналы, используя `docker logs -f <container-id>`. Вы поймете, что готовы к работе, когда увидите это...

    ```bash
    docker logs -f <container-id>
    $ nodemon src/index.js
    [nodemon] 2.0.20
    [nodemon] to restart at any time, enter `rs`
    [nodemon] watching path(s): *.*
    [nodemon] watching extensions: js,mjs,json
    [nodemon] starting `node src/index.js`
    Using sqlite database at /etc/todos/todo.db
    Listening on port 3000
    ```

    Когда вы закончите просмотр журналов, выйдите, нажав `Ctrl`+`C`.

1. Now, let's make a change to the app. In the `src/static/js/app.js` file, let's change the "Add Item" button to simply say
   "Add". This change will be on line 109 - remember to save the file.

1. Теперь внесем изменения в приложение. В файле `src/static/js/app.js` давайте изменим кнопку "Add Item", 
чтобы просто сказать "Add". Это изменение будет в строке 109 - не забудьте сохранить файл.

    ```diff
    -                         {submitting ? 'Adding...' : 'Add Item'}
    +                         {submitting ? 'Adding...' : 'Add'}
    ```

1. Просто обновите страницу (или откройте ее), и вы почти сразу увидите отражение изменений в браузере. 
Перезапуск сервера Node может занять несколько секунд, поэтому, если вы получите сообщение об ошибке, просто 
попробуйте обновить его через несколько секунд.

    ![Screenshot of updated label for Add button](updated-add-button.png){: style="width:75%;"}
    {: .text-center }

1. Не стесняйтесь вносить любые другие изменения, которые захотите. Когда вы закончите, остановите контейнер и создайте новый образ.
    используя `docker build -t getting-started .`.

Использование привязки монтирования _очень_ распространено при локальной 
разработке. Преимущество заключается в том, что на машине разработки не 
обязательно должны быть установлены все инструменты и среды сборки. С 
помощью одной команды `docker run` среда разработки запускается и готова к 
работе. Мы поговорим о Docker Compose на следующем этапе, так как это 
поможет упростить наши команды (мы уже получаем много флагов).

## Резюме

На этом этапе мы можем сохранить нашу базу данных и быстро реагировать на нужды и требования наших инвесторов и учредителей. Ура!
Но знаете что? Мы получили отличные новости!

**Ваш проект выбран для дальнейшего развития!**

Чтобы подготовиться к производству, нам нужно перевести нашу базу данных с 
работы в SQLite на что-то, что может немного лучше масштабироваться. Для 
простоты мы продолжим использовать реляционную базу данных и переключим 
наше приложение на использование MySQL. Но как нам запустить MySQL? Как мы 
позволяем контейнерам общаться друг с другом? Об этом мы поговорим дальше!